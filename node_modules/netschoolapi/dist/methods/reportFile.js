"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const checks_1 = require("../utils/checks");
function reportFile(credentials) {
    return __awaiter(this, void 0, void 0, function* () {
        const { url, filters, timeout = 6e4 } = credentials;
        const { client, session, context } = yield checks_1.sessionValid.call(this);
        const query = {
            _: session.ver,
            at: session.accessToken,
            transport: "webSockets",
            clientProtocol: 1.5,
            connectionData: '[{"name":"queuehub"}]',
        };
        const params = [
            { name: "DATEFORMAT", value: context.server.dateFormat },
            { name: "SCHOOLYEARID", value: context.year.id },
            { name: "SERVERTIMEZONE", value: 3 },
            { name: "FULLSCHOOLNAME", value: context.school.fullName },
        ];
        const { ConnectionToken } = (yield client
            .get("signalr/negotiate", { params: query })
            .then((res) => res.json()));
        query.connectionToken = ConnectionToken;
        const ws = client.ws("signalr/connect", { params: query });
        return new Promise((resolve, reject) => {
            let timeoutId = 0;
            ws.once("open", () => {
                client.get("signalr/start", { params: query });
                client
                    .post(url, {
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ params, selectedData: filters }),
                })
                    .then((res) => res.json())
                    .then(({ taskId }) => {
                    if (timeout > 0)
                        timeoutId = setTimeout(() => ws.close(4010), timeout);
                    ws.send(JSON.stringify({
                        I: 0,
                        H: "queuehub",
                        M: "StartTask",
                        A: [taskId],
                    }));
                })
                    .catch(() => ws.close(4001));
            });
            ws.on("message", (msg) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                let data;
                try {
                    data = JSON.parse(msg);
                }
                catch (e) {
                    return;
                }
                switch ((_b = (_a = data === null || data === void 0 ? void 0 : data.M) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.M) {
                    case "complete":
                        ws.close(4000);
                        const res = yield client.get("files/" + data.M[0].A[0].Data);
                        resolve(yield res.text());
                        break;
                    case "error":
                        ws.close(4003, data.M[0].A[0].Details);
                        break;
                }
            }));
            ws.once("error", (err) => ws.close(4002, err.message));
            ws.once("close", (code, message) => __awaiter(this, void 0, void 0, function* () {
                clearTimeout(timeoutId);
                yield client.post("signalr/abort", { params: query });
                switch (code) {
                    case 1000:
                    case 4000:
                        break;
                    case 4001:
                        reject(new Error("Error during initialization"));
                        break;
                    case 4002:
                        reject(new Error("Error in socket.\nError: " + message));
                        break;
                    case 4003:
                        reject(new Error("Error in task.\nError: " + message));
                        break;
                    case 4010:
                        reject(new Error("Response time expired"));
                        break;
                    default:
                        reject(new Error("Unknown error.\nError: " + message));
                }
            }));
        });
    });
}
exports.default = reportFile;
//# sourceMappingURL=reportFile.js.map