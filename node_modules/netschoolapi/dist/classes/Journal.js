"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dateNum_1 = require("../utils/dateNum");
const parseHtml_1 = require("../utils/parseHtml");
const MONTHS = {
    Сентябрь: "08",
    Октябрь: "09",
    Ноябрь: "10",
    Декабрь: "11",
    Январь: "12",
    Февраль: "13",
    Март: "14",
    Апрель: "15",
    Май: "16",
    Июнь: "17",
    Июль: "18",
    Август: "19",
};
function parseDates(yearStart, monthsTr, daysTr) {
    const days = daysTr.querySelectorAll("th").map((th) => +th.structuredText);
    const months = monthsTr.querySelectorAll("[colspan]").map((th) => {
        var _a;
        return ({
            length: +((_a = th.getAttribute("colspan")) !== null && _a !== void 0 ? _a : ""),
            number: +MONTHS[th.structuredText],
        });
    });
    const result = [];
    months.forEach(({ number, length }) => {
        const resultLength = result.length;
        for (let i = resultLength; i < resultLength + length; i++) {
            const date = new Date(yearStart);
            date.setDate(days[i]);
            date.setMonth(number);
            result.push(date);
        }
    });
    return result;
}
class Journal {
    constructor(credentials) {
        var _a, _b;
        this.raw = credentials.htmlText;
        this._subjects = credentials.subjects;
        const [start, end] = (_b = (_a = (0, parseHtml_1.query)(this.raw, "table td:nth-child(2) > span:nth-child(5)")) === null || _a === void 0 ? void 0 : _a.structuredText.match(/((\d{1,2}\.){2}\d{2})/g)) !== null && _b !== void 0 ? _b : [];
        this.range = { start: (0, dateNum_1.str2date)(start), end: (0, dateNum_1.str2date)(end) };
    }
    get subjects() {
        const trs = (0, parseHtml_1.table)({
            html: this.raw,
            query: ".table-print",
            removeHeaders: false,
        });
        const dates = parseDates(this.range.start, trs[0], trs[1]);
        trs.splice(0, 2);
        return trs.map((tr) => {
            var _a;
            const [nameTd, markTd] = tr.querySelectorAll("[class]");
            const name = nameTd.rawText.trim();
            const middleMark = +markTd.rawText.replace(",", ".");
            const marks = [];
            const missedList = [];
            tr.querySelectorAll(":not([class])").forEach((td, i) => {
                var _a, _b;
                const date = dates[i];
                const content = td.rawText.trim();
                if (!content)
                    return;
                (_a = content
                    .match(/\d/g)) === null || _a === void 0 ? void 0 : _a.forEach((str) => marks.push({ mark: +str, date }));
                (_b = content
                    .match(/[А-Яа-я]+/g)) === null || _b === void 0 ? void 0 : _b.forEach((type) => missedList.push({ type, date }));
            });
            return {
                id: ((_a = this._subjects.find(({ name: n }) => n == name)) === null || _a === void 0 ? void 0 : _a.id) || NaN,
                name,
                marks,
                missedList,
                middleMark,
            };
        });
    }
    toJSON() {
        return {
            raw: this.raw,
            range: {
                start: (0, dateNum_1.date2JSON)(this.range.start),
                end: (0, dateNum_1.date2JSON)(this.range.end),
            },
            subjects: this.subjects.map((s) => (Object.assign(Object.assign({}, s), { marks: s.marks.map((m) => (Object.assign(Object.assign({}, m), { date: (0, dateNum_1.date2JSON)(m.date) }))), missedList: s.missedList.map((m) => (Object.assign(Object.assign({}, m), { date: (0, dateNum_1.date2JSON)(m.date) }))) }))),
        };
    }
}
exports.default = Journal;
//# sourceMappingURL=Journal.js.map